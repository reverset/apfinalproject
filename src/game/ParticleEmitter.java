package game;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;

import game.ecs.ECSystem;
import game.ecs.comps.Transform;

public class ParticleEmitter extends ECSystem {
    private float emitAngle;
    private float angleVariation;
    private int maxParticles;
    private Duration nextParticleDuration;
    private Duration particleLifetime;

    private Consumer<Particle> particleRenderer;
    private Function<Double, Double> sizeOverTime;
    private Function<Double, Double> speedOverTime;

    private Stopwatch spawnStopwatch = Stopwatch.ofGameTime();

    private List<Particle> particles = new ArrayList<>();
    private Transform trans;
    private boolean relativePosition;
    private float spawnRadius;
    private SpawnStrategy spawnStrategy;
    private Duration lifetimeVariation;
    private int particlesSpawned = 0;
    private int totalMaxParticles;

    public enum SpawnStrategy {
        PERIMETER,
        AREA
    }

    public class Particle {
        private Vec2 position = new Vec2();
        private Vec2 realPosition = new Vec2();
        private Vec2 velocity = new Vec2();
        private double size = 1;
        private double spawnTime = GameLoop.getUnpausedTime();
        private double timeAlive = 0;
        private double lifetime = 0;

        public double getLifetime() {
            return lifetime;
        }

        public double getTimeAlive() {
            return timeAlive;
        }

        public double getSize() {
            return size;
        }

        public Vec2 getPosition() {
            return position;
        }

        public Vec2 getVelocity() {
            return velocity;
        }

        public void setVelocity(Vec2 velocity) {
            this.velocity = velocity;
        }

        public void setPosition(Vec2 pos) {
            position = pos;
        }

        public void setSize(double size) {
            this.size = size;
        }

        public double getSpawnTime() {
            return spawnTime;
        }

        public Vec2 getRealPosition() {
            if (relativePosition) {
                realPosition.setEq(position.x + trans.position.x, position.y + trans.position.y);
                return realPosition;
            }
            return position;
        }
    }

    public static EntityOf<ParticleEmitter> makeEntity(ParticleEmitter pe, Vec2 position, String name) {
        EntityOf<ParticleEmitter> e = new EntityOf<>(name, ParticleEmitter.class);

        e
            .addComponent(new Transform(position))
            .register(pe);

        return e;
    }

    /**
     * A generic and customizable Particle Emitter. See ParticlePresets.java for an easier to use interface.
     * 
     * @param emitAngle The angle at which to emit at.
     * @param angleVariation Random angle variation to add into the emitAngle.
     * @param maxParticles The maximum amount of particles present at a time.
     * @param nextParticleDuration The amount of time that must pass before another particle is spawned.
     * @param particleLifetime The lifetime of a singular particle.
     * @param lifetimeVariation The randomness added into the lifetime of a particle.
     * @param relativePosition Whether or not all particle positions should be relative to the emitter.
     * @param totalMaxParticles The maximum amount of particles to be spawned ever.
     * @param spawnRadius The radius from the emitter to spawn particles.
     * @param spawnStrategy Spawn particles at the permeter or the area of the circle generated by the radius.
     * @param particleRenderer A function to render each individual particle.
     * @param sizeOverTime A function to determine the size of each particle over time.
     * @param speedOverTime A function to determine the speed of a particle over time.
     */
    public ParticleEmitter(
            float emitAngle, 
            float angleVariation, 
            int maxParticles,
            Duration nextParticleDuration,
            Duration particleLifetime,
            Duration lifetimeVariation,
            boolean relativePosition,
            int totalMaxParticles,
            float spawnRadius,
            SpawnStrategy spawnStrategy,
            Consumer<Particle> particleRenderer,
            Function<Double, Double> sizeOverTime,
            Function<Double, Double> speedOverTime) {
        this.emitAngle = emitAngle;
        this.angleVariation = angleVariation;
        this.maxParticles = maxParticles;
        this.nextParticleDuration = nextParticleDuration;
        this.particleLifetime = particleLifetime;
        this.lifetimeVariation = lifetimeVariation;
        this.relativePosition = relativePosition;
        this.totalMaxParticles = totalMaxParticles;
        this.spawnRadius = spawnRadius;
        this.spawnStrategy = spawnStrategy;
        this.particleRenderer = particleRenderer;
        this.sizeOverTime = sizeOverTime;
        this.speedOverTime = speedOverTime;
    }

    @Override
    public void setup() {
        trans = require(Transform.class);
    }

    public Duration getMaximumLength() {
        return particleLifetime.plus(lifetimeVariation);
    }

    public int getTotalSpawnedParticleCount() {
        return particlesSpawned;
    }
    
    @Override
    public void frame() {
        while ((totalMaxParticles == -1 || particlesSpawned < totalMaxParticles) && particles.size() <= maxParticles && (nextParticleDuration.isZero() || spawnStopwatch.hasElapsedAdvance(nextParticleDuration))) {
            Particle particle = new Particle();
            particle.lifetime = (particleLifetime.toMillis() / 1_000.0) + (MoreMath.random(0, lifetimeVariation.toMillis()) / 1_000.0);
            
            particlesSpawned += 1;

            if (!relativePosition) {
                particle.getPosition().setEq(trans.position.x, trans.position.y);
            }
            if (spawnStrategy == SpawnStrategy.PERIMETER) particle.getPosition().addRandomByCoeffEq(spawnRadius);
            else if (spawnStrategy == SpawnStrategy.AREA) particle.getPosition().addRandomByCoeffEq(0, spawnRadius);

            particle.getVelocity()
                .setFromAngleEq((float)(emitAngle + MoreMath.randomExcluding(-angleVariation, angleVariation)))
                .multiplyEq((speedOverTime.apply(particle.timeAlive).floatValue()));
            particles.add(particle);
        }

        for (int i = particles.size()-1; i >= 0; i--) {
            Particle particle = particles.get(i);
            if (GameLoop.getUnpausedTime() > particle.getSpawnTime() + particle.lifetime) {
                particles.remove(i);
                continue;
            }

            particle.timeAlive = GameLoop.getUnpausedTime() - particle.spawnTime;

            Vec2 dV = particle.velocity.multiply(delta());
            particle.position.addEq(dV);

            particle.setSize(sizeOverTime.apply(particle.timeAlive));
        }
    }

    @Override
    public void render() {
        for (Particle particle : particles) {
            particleRenderer.accept(particle);
        }
    }
}
